<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Writing good code 2 - the SOLID principles applied to scientific code | Konstantin Gregor </title> <meta name="author" content="Konstantin Gregor"> <meta name="description" content="A discussion of the most important paradigms of professional software development and how they can help us write good code in science."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://k-gregor.github.io/blog/2024/good-code-2-solid-principles/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Konstantin</span> Gregor </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/courses/">courses </a> </li> <li class="nav-item "> <a class="nav-link" href="/funstuff/">fun stuff </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Writing good code 2 - the SOLID principles applied to scientific code</h1> <p class="post-meta"> Created on October 27, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/code"> <i class="fa-solid fa-hashtag fa-sm"></i> code</a>     ·   <a href="/blog/category/code"> <i class="fa-solid fa-tag fa-sm"></i> code</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>In my post about <a href="/blog/2024/good-code-1-proper-naming-in-scientific-code/">variable naming and function extraction</a> I tried to convey how simple it is to make code readable and understandable.</p> <p>Tthere are a few other software development paradigms and principles that aid in creating such understandable, but also maintainable, extendable, and testable code. Five core principles for object-oriented software design have been developed by Robert Martin and later termed by the acronym SOLID by Michael Feathers (Martin, 2000). These principles have been developed for agile software development where adaptations and new features have to be implemented in fast iterations. This is obviously not usually the case in scientific modeling. Nevertheless, they can be helpful also for scientific code because they help in making code more testable and maintainable, which is why I want to explain them here.</p> <h1 id="the-solid-principles-of-object-oriented-programming-languages">The SOLID principles of object-oriented programming languages</h1> <p>The five SOLID principles are the following:</p> <ol> <li>The <strong>S</strong>ingle responsibilty principle states that classes (or functions) should be responsible for one thing only. This allows clear distinction of what is done where.</li> <li>The <strong>O</strong>pen-closed principle constitutes that code should be open for extension (allowing new functionality) but closed to modification (the extension should not require modification of the existing code).</li> <li>The <strong>L</strong>iskov substitution principle formalizes proper usage of inheritance.</li> <li>The <strong>I</strong>nterface segregation principle defines that the interfaces between modules should be kept as small as possible to restrict unnecessary access, thereby limiting room for erronous behavior.</li> <li>The <strong>D</strong>ependency inversion principle states how to deal with modules depending on one another and how to handle dependencies for better testability.</li> </ol> <p>By the way, although they were developed for object-oriented programming, the SOLID principles are also applicable (in adapted form) to functional programming (see, e.g., Kocik (2022)).</p> <p>Here they are in more detail:</p> <h2 id="1-single-responsibility-principle">1. Single responsibility principle</h2> <p>Extracting well-named functions can be helpful to make code more understandable, maintainable, and testable. This is achieved best when these functions are not overloaded but ideally do <strong>one particular thing only</strong>. This idea is called the <em>single responsibility principle</em>. The principle was introduced for classes but holds for functions as well. A class that computes the radiation budget at the Earth’s surface should not also compute the water budget. These two things are of course heavily related, but should be split up if possible.</p> <p>Look at the following example code snippet adapted from the dynamic vegetation model LPJ-GUESS (Smith et al., 2014). All logic is divided into multiple functions that get called one after the other. This is a good example of the single responsibility principle where each function deals with one thing.</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> <td class="code"><pre><span class="kt">void</span> <span class="nf">simulateDay</span><span class="p">()</span> <span class="p">{</span>
<span class="p">...</span>
<span class="n">leafPhenology</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">climate</span><span class="p">);</span>
<span class="n">interception</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">climate</span><span class="p">);</span>
<span class="n">initialInfiltration</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">climate</span><span class="p">);</span>
<span class="n">canopyGasExchange</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">climate</span><span class="p">);</span>
<span class="n">irrigation</span><span class="p">(</span><span class="n">patch</span><span class="p">);</span>
<span class="n">soilwater</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">climate</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <div class="caption"> This example code adapted from the dynamic vegetation model LPJ-GUESS nicely extracts code into different functions with clear names that are responsible for one thing. </div> <h2 id="2-open-closed-principle">2. Open-closed principle</h2> <p>Code should be open for extension, but closed for modification. This means, that the class itself should be able to deal with new requirements without changing anything within that class.</p> <p>Consider the following example adapted from LPJ-GUESS computing leaf phenology. The code is technically not open for extension. If a new plant lifeform is added, we need to modify this code and add another <code class="language-plaintext highlighter-rouge">if</code>.</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> <td class="code"><pre><span class="kt">void</span> <span class="nf">leafPhenology</span><span class="p">(</span><span class="n">Plant</span> <span class="n">plant</span><span class="p">,</span> <span class="n">Climate</span> <span class="n">climate</span><span class="p">){</span>
<span class="c1">// ...</span>
<span class="kt">double</span> <span class="n">phenology</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">lifeform</span> <span class="o">==</span> <span class="n">TREE</span><span class="p">){</span>
<span class="n">phenology</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">climate</span><span class="p">.</span><span class="n">gdd5</span> <span class="o">-</span> <span class="n">plant</span><span class="p">.</span><span class="n">gdd0</span><span class="p">[</span><span class="n">climate</span><span class="p">.</span><span class="n">chilldays</span><span class="p">])</span> <span class="o">/</span> <span class="n">pft</span><span class="p">.</span><span class="n">phengdd5ramp</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">plant</span><span class="p">.</span><span class="n">lifeform</span> <span class="o">==</span> <span class="n">GRASS</span><span class="p">)</span> <span class="p">{</span>  
 <span class="n">phenology</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">climate</span><span class="p">.</span><span class="n">gdd5</span> <span class="o">/</span> <span class="n">plant</span><span class="p">.</span><span class="n">phengdd5ramp</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// ...</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <div class="caption">This code violates the open-closed principle.</div> <p>Here, it could be better to make use of inheritance in object-oriented languages. One could introduce classes <code class="language-plaintext highlighter-rouge">Tree</code> and <code class="language-plaintext highlighter-rouge">Grass</code> that implement an interface (or extend an abstract class) <code class="language-plaintext highlighter-rouge">Plant</code> that has a method <code class="language-plaintext highlighter-rouge">phenology()</code>. Then, we can call <code class="language-plaintext highlighter-rouge">plant.phenology()</code> directly without having to check its type again. And adding a new type of plant would not change any code in the adapted snippet below. The new plant would implement their own <code class="language-plaintext highlighter-rouge">phenology()</code> function:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> <td class="code"><pre><span class="kt">void</span> <span class="nf">leafPhenology</span><span class="p">(</span><span class="n">Plant</span> <span class="n">plant</span><span class="p">,</span> <span class="n">Climate</span> <span class="n">climate</span><span class="p">){</span>
<span class="c1">// ...</span>
<span class="kt">double</span> <span class="n">phenology</span> <span class="o">=</span> <span class="n">plant</span><span class="p">.</span><span class="n">phenology</span><span class="p">(</span><span class="n">climate</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">public</span> <span class="n">interface</span> <span class="n">Plant</span> <span class="p">{</span>
<span class="k">public</span> <span class="kt">double</span> <span class="n">phenology</span><span class="p">(</span><span class="n">Climate</span> <span class="n">climate</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Tree</span> <span class="n">extends</span> <span class="n">Plant</span> <span class="p">{</span>
<span class="k">public</span> <span class="kt">double</span> <span class="n">phenology</span><span class="p">(</span><span class="n">Climate</span> <span class="n">climate</span><span class="p">){</span>
<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="p">(</span><span class="n">climate</span><span class="p">.</span><span class="n">gdd5</span> <span class="o">-</span> <span class="n">gdd0</span><span class="p">[</span><span class="n">climate</span><span class="p">.</span><span class="n">chilldays</span><span class="p">])</span> <span class="o">/</span> <span class="n">phengdd5ramp</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Grass</span> <span class="n">extends</span> <span class="n">Plant</span> <span class="p">{</span>
<span class="k">public</span> <span class="kt">double</span> <span class="n">phenology</span><span class="p">(</span><span class="n">Climate</span> <span class="n">climate</span><span class="p">){</span>
<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">climate</span><span class="p">.</span><span class="n">gdd5</span> <span class="o">/</span> <span class="n">phengdd5ramp</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <div class="caption"> This example is open for extension and closed for modification. The function `leafPhenology` will not need to be adapted if a new type of plant is introduced.</div> <p>This way of organizing the code is more maintainable, because we do not need to touch <code class="language-plaintext highlighter-rouge">leafPhenology</code> again if we want to change the behavior of <code class="language-plaintext highlighter-rouge">Tree</code>s or <code class="language-plaintext highlighter-rouge">Grass</code>es or add a new type of <code class="language-plaintext highlighter-rouge">Plant</code>. It needs to be noted, however, that for a single such situation it is probably not worth designing a new class hierarchy. Creating a class hierarchy needs to be well thought out, because it will be hard to change later. However, if you find yourself having to write similar if-else-statements around the model code, creating a class abstraction is probably sensible.</p> <h2 id="3-liskov-substitution-principle">3. Liskov substitution principle</h2> <p>A benefit of object-oriented programming is the concept of inheritance, where a subclass is derived from a superclass to extend the behavior of that superclass. We have seen this above already in the Open-close principle.</p> <p>The introduced <code class="language-plaintext highlighter-rouge">Plant</code> interface (it could also be a class) will have sub-types like <code class="language-plaintext highlighter-rouge">Tree</code>, which will in turn have other subtypes, for instance <code class="language-plaintext highlighter-rouge">NeedleleavedTree</code> and <code class="language-plaintext highlighter-rouge">BroadleavedTree</code>. In this regard, the Liskov substitution principle is the principle guaranteeing that no inconsistent behavior happens when creating such a hierarchy. It states that if class A is a subtype of B, we should be able to use objects of type A and B interchangeably without breaking the behavior of the model.</p> <p>Basically this boils down to designing a proper inheritance hierarchy. An example violating this rule is found below.</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> <td class="code"><pre><span class="k">class</span> <span class="nc">BroadleavedTree</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">leafOut</span><span class="p">(){</span>
<span class="c1">// grow broad leaves</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">senescence</span><span class="p">(){</span>
<span class="c1">// drop leaves in autumn</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">CommonOak</span> <span class="n">extends</span> <span class="n">BroadleavedTree</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">HolmOak</span> <span class="n">extends</span> <span class="n">BroadleavedTree</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <div class="caption"> The problem here is that unlike most broad-leaved trees, a holm oak actually is also an evergreen tree and does not drop its leaves. The class hierarchy is therefore not ideal. </div> <p>In general it is simply important to keep in mind that class types need to be interchangeable when designing the hierarchy (e.g., a class <code class="language-plaintext highlighter-rouge">Bird</code> would probably have a method <code class="language-plaintext highlighter-rouge">fly()</code>, but then there are birds that don’t fly). There are numerous ways to fix a violation of the principle, for instance redesigning the class hierarchy or not using inheritance where we don’t need to (this is also called <strong>composition over inheritance</strong>).</p> <p>In the given example, the method <code class="language-plaintext highlighter-rouge">senescence()</code> could be extracted from the class <code class="language-plaintext highlighter-rouge">BroadleavedTree</code> into an interface <code class="language-plaintext highlighter-rouge">Summergreen</code>, because this method is not really tied to the characteristic of a tree having broad leaves. This would allow creating various broad-leaved trees that can drop their leaves or not, depending on whether the interface is implemented or not, like so:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="code"><pre><span class="k">class</span> <span class="nc">BroadleavedTree</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">leafOut</span><span class="p">(){</span>
<span class="c1">// grow broad leaves</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="n">interface</span> <span class="n">Summergreen</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">senescence</span><span class="p">(){</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">CommonOak</span> <span class="n">extends</span> <span class="n">BroadleavedTree</span> <span class="n">implements</span> <span class="n">Summergreen</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">class</span> <span class="nc">HolmOak</span> <span class="n">extends</span> <span class="n">BroadleavedTree</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <div class="caption"> Extracting the senescence function into an interface makes the class hierarchy correct again.. </div> <h2 id="4-interface-segregation">4. Interface segregation</h2> <p>We’ve seen above already how interfaces can be helpful to hide away logic from other parts of the code (see the example of the Open-closed principle).</p> <p>There is one additional golden rule about creating such interfaeces: Instead of creating one large interface it is advisable to create multiple small ones. Then at another point in the software, only the ``small’’ interface is addressed, providing only what is relevant at this point. Note that interfaces do not exist in all programming languages, but they can often be emulated by other features of those languages.</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td> <td class="code"><pre><span class="k">public</span> <span class="n">interface</span> <span class="n">Plant</span><span class="p">{</span>
<span class="n">takeUpWater</span><span class="p">();</span>
<span class="n">phenology</span><span class="p">();</span>
<span class="n">doPhotosynthesis</span><span class="p">();</span>
<span class="n">respire</span><span class="p">();</span>
<span class="n">grow</span><span class="p">();</span>
<span class="n">die</span><span class="p">();</span>
<span class="n">harvest</span><span class="p">();</span>
<span class="n">sow</span><span class="p">();</span>
<span class="n">irrigate</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Cropland</span> <span class="p">{</span>
<span class="k">public</span> <span class="kt">void</span> <span class="n">prepareField</span><span class="p">(</span><span class="n">Plant</span> <span class="n">plant</span><span class="p">){</span>
<span class="c1">// calling functions like plant.doPhotosynthesis() or plant.respire()</span>
<span class="c1">// would be possible here. But is this reasonable?</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <div class="caption"> Example of a potentially too large interface. The `Cropland` class should not be able to deal with low-level aspects of a `Plant`. </div> <p>Every part of the code receiving a <code class="language-plaintext highlighter-rouge">Plant</code> now can do anything with that object. According to <em>interface segregation</em>, we should hide unneeded details. In this example, it would make sense to extract at least one other interface:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td> <td class="code"><pre><span class="k">public</span> <span class="n">interface</span> <span class="n">Plant</span><span class="p">{</span>
<span class="n">takeUpWater</span><span class="p">();</span>
<span class="n">phenology</span><span class="p">();</span>
<span class="n">doPhotosynthesis</span><span class="p">();</span>
<span class="n">respire</span><span class="p">();</span>
<span class="n">grow</span><span class="p">();</span>
<span class="n">die</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="n">interface</span> <span class="n">ManageablePlant</span><span class="p">{</span>
<span class="n">harvest</span><span class="p">();</span>
<span class="n">sow</span><span class="p">();</span>
<span class="n">irrigate</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Cropland</span> <span class="p">{</span>
<span class="k">public</span> <span class="kt">void</span> <span class="n">prepareField</span><span class="p">(</span><span class="n">ManageablePlant</span> <span class="n">plant</span><span class="p">){</span>
<span class="c1">// plant.doPhotosynthesis() or plant.respire() can not be called here</span>
<span class="c1">// only methods of ManageablePlant (i.e., methods relevant to land use) can be</span>
<span class="c1">// called here, e.g., plant.sow() or plant.harvest()</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <div class="caption"> An example of a segregation of the interfaces of the previous code snippet. In a land use component, only the functions of `ManageablePlant` should be visible. </div> <p>In a land use component of an earth system model, we then only need to pass the <code class="language-plaintext highlighter-rouge">ManageablePlant</code> and we can be sure that only the functions of that interface are called. The land use component will not be able to mess with other aspects which it is not responsible for, because these are hidden. For instance, <code class="language-plaintext highlighter-rouge">doPhotosynthesis</code> should probably not be called from any land use parts of the model and is therefore not part of the interface <code class="language-plaintext highlighter-rouge">ManageablePlant</code>.</p> <p>In a programming language without interfaces, similar results may be achieved through other means, for instance virtual methods and abstract classes.</p> <h2 id="5-dependency-inversion">5. Dependency inversion</h2> <p>This principle aims at decoupling modules from one another. High level logic should not depend on a particular implementation at a low level. In regular software this is essential to switch out modules easily, e.g. replace a data source.</p> <p>This is probably not a crucial thing in scientific code and models. However, there is one critical benefit of this principle: It makes the code more testable, because we can plug in and test things easily because you can pass things directly. A negative example is shown in the following code snippet. The <code class="language-plaintext highlighter-rouge">simulateClimateProjection</code>-function is hard to test, because we cannot easily test what happens under various climates.</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> <td class="code"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">Gridcell</span><span class="p">{</span>
<span class="k">private</span> <span class="n">Climate</span> <span class="n">climate</span><span class="p">;</span>
<span class="k">public</span> <span class="n">Gridcell</span><span class="p">(){</span>
<span class="k">this</span><span class="p">.</span><span class="n">climate</span> <span class="o">=</span> <span class="n">readClimateFromFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">simulateClimateProjection</span><span class="p">(){</span>
<span class="kt">double</span> <span class="n">temperature</span> <span class="o">=</span> <span class="n">climate</span><span class="p">.</span><span class="n">getTemperature</span><span class="p">();</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <div class="caption"> This code violates the dependency inversion principle. The high level class `Gridcell` depends on the implementation of `Climate`. </div> <p>An improved implementation is achieved by passing the climate through the constructor. In a testing environment, various climate objects can be created and passed.</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> <td class="code"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">Gridcell</span><span class="p">{</span>
<span class="k">private</span> <span class="n">Climate</span> <span class="n">climate</span><span class="p">;</span>
<span class="k">public</span> <span class="n">Gridcell</span><span class="p">(</span><span class="n">Climate</span> <span class="n">climate</span><span class="p">){</span>
<span class="k">this</span><span class="p">.</span><span class="n">climate</span> <span class="o">=</span> <span class="n">climate</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">simulateClimateProjection</span><span class="p">(){</span>
<span class="kt">double</span> <span class="n">temperature</span> <span class="o">=</span> <span class="n">climate</span><span class="p">.</span><span class="n">getTemperature</span><span class="p">();</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <div class="caption"> In this example, the dependency of `Gridcell` on `Climate` is being injected. `Gridcell` does not have to create the `Climate` itself because it is *injected*. This makes it easier to test: In a unit test, we can pass different climates and call `simulateClimateProjection()`. </div> <p>When testing the code, we can now simply insert our own <code class="language-plaintext highlighter-rouge">Climate</code> when creating a <code class="language-plaintext highlighter-rouge">Gridcell</code> and easily test what happens when we run <code class="language-plaintext highlighter-rouge">simulateClimateProjection</code> after having passed various climates.</p> <h1 id="conclusion">Conclusion</h1> <p>For a scientist, this was probably quite the deep-dive into topics of software engineering. However, I believe that one needs to simple remember the gist of these SOLID principles:</p> <ol> <li>Code portions should have one responsibility and not do hundred things</li> <li>Code should be designed that modifications or extensions need minimal adaptation of code</li> <li>Code that can take different arguments should work for all types of arguments that they allow</li> <li>Internal logic that can be hidden should be hidden</li> <li>Code at a high level should be designed in a way that it is independent from implementations at low levels.</li> </ol> <p>All this also makes code more understandable, maintainable, and testable.</p> <h1 id="references">References</h1> <ul> <li>Kocik, M. (2022). SOLID principles in Functional Programming. <a href="https://medium.com/@mkocik/solid-principles-in-functional-programming-b9b83aeddf80" rel="external nofollow noopener" target="_blank">https://medium.com/@mkocik/solid-principles-in-functional-programming-b9b83aeddf80</a> </li> <li>Martin, R. C. (2000). Design Principles and Design Patterns. Object Mentor. <a href="http://labs.cs.upt.ro/labs/ip2/html/lectures/2/res/Martin-PrinciplesAndPatterns.PDF" rel="external nofollow noopener" target="_blank">http://labs.cs.upt.ro/labs/ip2/html/lectures/2/res/Martin-PrinciplesAndPatterns.PDF</a> </li> <li>Smith, B., Wårlind, D., Arneth, A., Hickler, T., Leadley, P., Siltberg, J., &amp; Zaehle, S. (2014). Implications of incorporating N cycling and N limitations on primary production in an individual-based dynamic vegetation model. Biogeosciences, 11(7), 2027–2054. <a href="https://doi.org/10.5194/bg-11-2027-2014" rel="external nofollow noopener" target="_blank">https://doi.org/10.5194/bg-11-2027-2014</a> </li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/good-code-1-proper-naming-in-scientific-code/">Writing good code 1 - Naming, comments, functions, and the DRY principle</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/radiative-forcing/">A comprehensive explanation of radiative forcing and friends</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/memory-aspects-in-scientific-coding/">Memory aspects in scientific coding</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/life-hacks-for-a-successful-phd/">9 life hacks for a successful PhD (or other knowledge work)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/commandline/">5 Must-know command-line commands for scientists</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Konstantin Gregor. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?b7816bd189846d29eded8745f9c4cf77"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.min.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-12YX5QG8PE"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-12YX5QG8PE");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>